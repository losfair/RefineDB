use super::ast::*;
use super::QlError;
use super::state::State;
use lalrpop_util::ParseError;
use bumpalo::collections::vec::Vec as Bvec;

grammar(state: &mut State<'input>);

extern {
  type Error = QlError;
}

pub QlRoot: QlRoot<'input> = {
  <graphs:QlGraph*> => QlRoot {
    graphs: Bvec::from_iter_in(graphs.into_iter(), &state.alloc),
  }
}

QlGraph: QlGraph<'input> = {
  "graph" <name:Identifier> "{" "}" => QlGraph {
    name,
  }
}

Identifier: &'input str = {
  <s:Token<r"[a-zA-Z_][0-9a-zA-Z_]*">> => state.resolve_str(s),
}

Literal: Literal<'input> = {
  <s:Token<r"[0-9]+">> =>? s.parse().map(Literal::Integer).map_err(|_| ParseError::User {
    error: QlError::InvalidLiteral,
  }),
  <s:Token<r"0x[0-9a-fA-F]+">> =>? i64::from_str_radix(s.strip_prefix("0x").unwrap(), 16).map(Literal::Integer).map_err(|_| ParseError::User {
    error: QlError::InvalidLiteral,
  }),
  <s:Token<r"0o[0-9a-fA-F]+">> =>? i64::from_str_radix(s.strip_prefix("0o").unwrap(), 8).map(Literal::Integer).map_err(|_| ParseError::User {
    error: QlError::InvalidLiteral,
  }),
  <s:Token<r"0b[0-9a-fA-F]+">> =>? i64::from_str_radix(s.strip_prefix("0b").unwrap(), 2).map(Literal::Integer).map_err(|_| ParseError::User {
    error: QlError::InvalidLiteral,
  }),
  <s:StringLit> => Literal::String(state.resolve_str(&s)),
}

StringLit: String = {
  <s:Token<r#""(\\.|[^"])*""#>> =>? serde_json::from_str::<String>(s)
    .map_err(|_| ParseError::User {
      error: QlError::InvalidLiteral,
    }),
}

ZeroOrMore<T, Delim>: Vec<T> = {
  <x:OneOrMore<T, Delim>?> => x.unwrap_or_default()
}

OneOrMore<T, Delim>: Vec<T> = {
  <i1: T> <i2:(Delim T)*> Delim? => {
    let mut items = vec![i1];
    items.extend(i2.into_iter().map(|e| e.1));
    items
  }
}

Token<I>: I = {
  <s:I> <c:Comment*> => s,
}

Comment: () = {
  r"//[^\n\r]*[\n\r]*" => { },
  r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => { },
}
