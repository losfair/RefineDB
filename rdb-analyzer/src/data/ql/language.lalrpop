use super::ast::*;
use super::QlError;
use super::state::State;
use lalrpop_util::ParseError;
use bumpalo::collections::vec::Vec as Bvec;

grammar(state: &mut State<'input>);

extern {
  type Error = QlError;
}

pub QlRoot: QlRoot<'input> = {
  Comment* <graphs:QlGraph*> => QlRoot {
    graphs: Bvec::from_iter_in(graphs.into_iter(), &state.alloc),
  }
}

QlGraph: QlGraph<'input> = {
  Token<"graph"> <name:Identifier>
    Token<"("> <params:ZeroOrMore<(Identifier ":" Type), ",">> Token<")">
    <return_type:(Token<":"> <Type>)?>
    Token<"{"> <stmts:(@L Stmt)*> Token<"}"> => QlGraph {
      name,
      params: Bvec::from_iter_in(params.into_iter().map(|x| (x.0, x.2)), &state.alloc),
      return_type,
      stmts: Bvec::from_iter_in(stmts.into_iter().map(|x| QlStmt {
        location: x.0,
        kind: x.1,
      }), &state.alloc)
    }
}

Type: QlType<'input> = {
  <name:Identifier> <params:(Token<"<"> <ZeroOrMore<Type, Token<",">>> Token<">">)?> => QlType {
    name,
    params: Bvec::from_iter_in(params.unwrap_or_default().into_iter(), &state.alloc),
  }
}

Stmt: QlStmtKind<'input> = {
  Token<"let"> <name:Identifier> Token<"="> <value:Expr> Token<";"> => QlStmtKind::Let {
    name,
    value,
  },
  <base:Expr> Token<"="> <value:Expr> Token<";"> => QlStmtKind::Assign {
    base, value,
  },
  <base:Expr> Token<"<-"> <value:Expr> Token<";"> => QlStmtKind::EffectAssign {
    base, value,
  }
}

Expr: QlExpr<'input> = {
  <location_start:@L> <kind:ExprKind> <location_end:@R> => QlExpr { location_start, location_end, kind },
  <e:ExprL2> => e,
}

ExprKind: QlExprKind<'input> = {
  Token<"<"> <ty:Type> Token<">"> <that:ExprL2> => QlExprKind::BuildTable(ty, state.alloc.alloc(that)),
}

ExprL2: QlExpr<'input> = {
  <location_start:@L> <kind:ExprKindL2> <location_end:@R> => QlExpr { location_start, location_end, kind },
  Token<"("> <e:Expr> Token<")"> => e,
}

ExprKindL2: QlExprKind<'input> = {
  <x:Literal> => QlExprKind::Primitive(x),
  <id:Identifier> => QlExprKind::ValueRef(id),
  <left:ExprL2> Token<"."> <right:Identifier> => QlExprKind::GetField(
    state.alloc.alloc(left),
    right,
  ),
  <x:ExprL2> Token<"!"> => QlExprKind::UnwrapOptional(state.alloc.alloc(x)),
  Token<"{"> <elements:ZeroOrMore<(Identifier ":" Expr), Token<",">>> Token<"}"> => QlExprKind::NewMap(
    Bvec::from_iter_in(elements.into_iter().map(|x| (x.0, x.2)), &state.alloc),
  ),
  <left:ExprL2> Token<"["> <key:Identifier> Token<"=="> <value:Expr> Token<"]"> => QlExprKind::GetSetElement(
    state.alloc.alloc(left),
    key,
    state.alloc.alloc(value),
  ),
}

Identifier: &'input str = {
  <s:Token<r"[a-zA-Z_][0-9a-zA-Z_]*">> => state.resolve_str(s),
}

Literal: Literal<'input> = {
  <s:Token<r"[0-9]+">> =>? s.parse().map(Literal::Integer).map_err(|_| ParseError::User {
    error: QlError::InvalidLiteral,
  }),
  <s:Token<r"0x[0-9a-fA-F]+">> =>? i64::from_str_radix(s.strip_prefix("0x").unwrap(), 16).map(Literal::Integer).map_err(|_| ParseError::User {
    error: QlError::InvalidLiteral,
  }),
  <s:Token<r"0o[0-9a-fA-F]+">> =>? i64::from_str_radix(s.strip_prefix("0o").unwrap(), 8).map(Literal::Integer).map_err(|_| ParseError::User {
    error: QlError::InvalidLiteral,
  }),
  <s:Token<r"0b[0-9a-fA-F]+">> =>? i64::from_str_radix(s.strip_prefix("0b").unwrap(), 2).map(Literal::Integer).map_err(|_| ParseError::User {
    error: QlError::InvalidLiteral,
  }),
  <s:StringLit> => Literal::String(state.resolve_str(&s)),
  <s:HexBytesLit> => Literal::HexBytes(s),
  Token<"null"> => Literal::Null,
}

StringLit: String = {
  <s:Token<r#""(\\.|[^"])*""#>> =>? serde_json::from_str::<String>(s)
    .map_err(|_| ParseError::User {
      error: QlError::InvalidLiteral,
    }),
}

HexBytesLit: &'input [u8] = {
  <s:Token<r#"h"([0-9a-fA-F][0-9a-fA-F])*""#>> =>? serde_json::from_str::<String>(s.strip_prefix("h\"").unwrap().strip_suffix("\"").unwrap())
    .map_err(|_| ParseError::User {
      error: QlError::InvalidLiteral,
    })
    .and_then(|x| hex::decode(&x)
      .map_err(|_| ParseError::User {
        error: QlError::InvalidLiteral,
      })
      .map(|x| state.alloc.alloc_slice_copy(&x) as &[u8])
    ),
}

ZeroOrMore<T, Delim>: Vec<T> = {
  <x:OneOrMore<T, Delim>?> => x.unwrap_or_default()
}

OneOrMore<T, Delim>: Vec<T> = {
  <i1: T> <i2:(Delim T)*> Delim? => {
    let mut items = vec![i1];
    items.extend(i2.into_iter().map(|e| e.1));
    items
  }
}

Token<I>: I = {
  <s:I> => s,
}

Comment: () = {
  r"//[^\n\r]*[\n\r]*" => { },
  r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => { },
}
